# Name: Eduardo Wang Zheng# Student ID: 518030990025#Key ideas:#1、replace the arithmetic operation with iaddl. At the same time, because iaddl has the #step of set CC, the corresponding andl instruction is unnecessary.#2. Loop unrolling. Unroll by a factor of 4, we can Eliminate unnecessary instructions. #Howerver, to handle the case that the number of elements is not divisible by 4, we need an#extra loop(Loop2) that simply copy src to dst one by one and check if the element we have #moved is valid in each test (test 1~5). If the element is valid, we increment the count(%eax).#/* $begin ncopy-ys */################################################################### ncopy.ys - Copy a src block of len ints to dst.# Return the number of positive ints (>0) contained in src.## Include your name and ID here.## Describe how and why you modified the baseline code.#################################################################### Do not modify this portion# Function prologue.ncopy:	pushl %ebp		# Save old frame pointer	rrmovl %esp,%ebp	# Set up new frame pointer	pushl %esi		# Save callee-save regs	pushl %ebx	pushl %edi	mrmovl 8(%ebp),%ebx	# src	mrmovl 16(%ebp),%edx	# len	mrmovl 12(%ebp),%ecx	# dst################################################################### You can modify this portion	# Loop header	xorl %eax,%eax      # count = 0;    iaddl $-3, %edx     # len- = 3    jle next_start      # if so, goto Done:Loop1:      mrmovl (%ebx), %esi # read val from src    mrmovl 4(%ebx), %edi # read val from src + 1    rmmovl %esi, (%ecx) # store src to dst    rmmovl %edi, 4(%ecx) # store src + 1 to dst + 1test1:    andl %esi, %esi     # *src <= 0 ?    jle test2           # if so, goto test2:    iaddl $1, %eax      # count++test2:    andl %edi, %edi     # *(src + 1) <= 0 ?    jle test3           # if so, goto test3:    iaddl $1, %eax      # count++test3:    mrmovl 8(%ebx), %esi # read val from src + 2    mrmovl 12(%ebx), %edi # read val from src + 3    rmmovl %esi, 8(%ecx) # store  src + 2 to dst + 2    rmmovl %edi, 12(%ecx) # store src + 3 to dst + 3    andl %esi, %esi     # *(src + 2) <= 0?    jle test4           # if so, goto test4:    iaddl $1, %eax      # count++test4:    andl %edi, %edi     # *(src + 3) <= 0?    jle Npos            # if so, goto Npos:    iaddl $1, %eax      # count++Npos:    iaddl $16, %ebx     # src += 4    iaddl $16, %ecx     # dst += 4    iaddl $-4, %edx     # len -= 4    andl %edx,%edx      # len > 0?    jg Loop1            # if so, goto Loop1:next_start:    iaddl $3, %edx      # len += 3    jle Done            # if len<=0, goto Done:loop2:    mrmovl (%ebx), %esi # read val from src    rmmovl %esi, (%ecx) # store src to dst    andl %esi, %esi     # *src <= 0 ?    jle test5           # if so, goto test5:    iaddl $1, %eax      # count++test5:    iaddl $4, %ebx      # src += 1    iaddl $4, %ecx      # dst += 1    iaddl $-1, %edx     # len -= 1    jg loop2            # if len>0, goto Done:################################################################### Do not modify the following section of code# Function epilogue.Done:	popl %edi               # Restore callee-save registers	popl %ebx	popl %esi	rrmovl %ebp, %esp	popl %ebp	ret################################################################### Keep the following label at the end of your functionEnd:#/* $end ncopy-ys */